Igor - Developer readme
=============

This readme contains helpful information pertaining to developing your own modules and more details about how Igor is structured.

## Overarching structure

Igor is composed of the [Updater Script](Editor/IgorUpdater.cs) and a series of Modules.  The Updater script downloads new modules and keeps all the modules up to date with what is in GitHub, even if you installed using the UnityPackage.

The updater pulls down the [list of all the public modules](IgorModuleList.xml) and then retrieves each individual module's Module Information XML file.

The Module Information XML file contains a list of all the files that are needed by the module.  It should contain at least:

1. The primary module class.
2. A Readme.md for the module.

You can look at the [full iOS module information XML file here](Modules/Build/iOS/iOS.xml) to see an example of a larger Module Information XML file.

### Module Information XML File

This file specifies all of the component source files and any necessary resource files that are required to perform the module's function.  Here are the components of the file along with some explanation of what goes in each slot:

#### Module Name

This is the name of the module and it should match the folder structure that the module is in.  For the [iOS builder module](Modules/Build/iOS/iOS.xml), you see:

```
<ModuleName>Build.iOS</ModuleName>
```

The period creates a grouping in the Igor Configuration Window and allows all the modules to be easily found by type.  If your new module can fit into one of the already existing categories, please use that instead of creating your own.  If you have a peculiar implementation, you can either keep your module local (see the section on Local Modules below) or you can append a unique identifier to the end of the module name (see for instance the [FacebookiOSHats module](Modules/3rdParty/FacebookiOSHats/IgorFacebookiOSHats.xml)).

#### Module Version

This is a manually incremented version number for the module.  There is only one version number for all the files in the module and this is used to see if there is a newer version available.  If you increment this number in the primary GitHub branch, any Igor user on any project that has updates enabled will automatically pull down the latest version of every file in that module.

#### Module Files

This section contains a list of all the files required by the module.  The format for file paths has a few different options.

1. Files that you have written and are submitting to the Igor GitHub project and that don't need to be placed in a special location.  An example in the [iOS builder module](Modules/Build/iOS/iOS.xml) would be the primary builder C# file:

	```
	<File>Editor/IgorBuildiOS.cs</File>
	```

	- This tells Igor to look for the file Modules/Build/iOS/IgorBuildiOS.cs in the GitHub repo (or your local directory if you have the Local update option enabled) and place it in Assets/Igor/Modules/Build/iOS/Editor/IgorBuildiOS.cs
		- This path is generated by appending the Module's two name components (in this case Build and iOS) as separate folders to the base Modules folder that all Module files are contained in.

2. Files that are hosted on another third-party site or a different GitHub project can be linked directly.  An example in the [iOS builder module](Modules/Build/iOS/iOS.xml) would be PBXBuildFile.cs file:

	```
    <File>(https://raw.githubusercontent.com/dcariola/XCodeEditor-for-Unity/master/)[Editor/XCodeEditor/]PBXBuildFile.cs</File>
    ```

    1. The syntax here is the remote directory inside the parentheses (in this case https://raw.githubusercontent.com/dcariola/XCodeEditor-for-Unity/master/), the local relative path in square brackets (in this case XCodeEditor), and the shared filename at the end (in this case PBXBuildFile.cs).
    2. The full remote path is generated by combining what's in the parentheses with the shared filename.  For this example that would be:
    	https://raw.githubusercontent.com/dcariola/XCodeEditor-for-Unity/master/PBXBuildFile.cs
    3. The full local path is generated by combining the same directory structure as for normal files above, appending the local relative path, and finally the shared path.  For this example that would be:
    	Assets/Igor/Modules/Build/iOS/Editor/XCodeEditor/PBXBuildFile.cs
    4. Note that you don't need to specify both a custom remote directory and a custom local relative path.  If you have some reason you want to specify only a custom remote path or only a custom local relative path, you can do that.  You can also specify a sub-directory in the shared filename to keep larger modules internally organized.

#### Module Dependencies

Some modules will specify dependencies in their XML file (note that you do not need to specify Core.Core since every module is dependent on that).  Using the [iOS builder module](Modules/Build/iOS/iOS.xml) as an example, you can see:

```
<ModuleDependencies>
  <Module>Build.Common</Module>
</ModuleDependencies>
```

When a module specifies dependencies they are automatically retrieved and kept up to date along with any explicitly enabled modules.


### Module C# Structure

Each module contains one class that derives from [IIgorModule](Modules/Core/Core/Editor/IIgorModule.cs), although it is highly recommended to derive from [IgorModuleBase](Modules/Core/Core/Editor/IgorModuleBase.cs) since there are numerous helper functions in [IgorModuleBase](Modules/Core/Core/Editor/IgorModuleBase.cs) that are useful for every module.  Regardless of what you derive from, in the Module's primary class, you need to:

1. Swap the name returned by GetModuleName()
2. Register the module with Core in an override of RegisterModule():

	```
	IgorCore.RegisterNewModule(this);
	```

	- You can also optionally check the return value from RegisterNewModule() to see if this is the first time we have registered.  This can be useful for clearing state (see the [Build Common Module](Modules/Build/Common/Editor/IgorBuildCommon.cs) for an example):

	```
	bool DidRegister = IgorCore.RegisterNewModule(this);

    if(DidRegister)
    {
        AvailablePlatforms.Clear();
    }
	```

3. Process the arguments for a given job in ProcessArgs() to see if this module is enabled and register with the StepHandler that's passed into the function.
	- For example, the [Desktop Builder class](Modules/Build/Desktop/Editor/IgorBuildDesktop.cs) only registers job steps if the platform is OSX or Windows.
4. Override DrawJobInspectorAndGetEnabledParams() to show the parameters that are available for configuring your module.
	- An obvious example is a checkbox to build the game in the [Build Common Module](Modules/Build/Common/Editor/IgorBuildCommon.cs)
5. Optionally override ShouldDrawInspectorForParams() to conditionally hide the entire module in the configuration options window.

#### Parameters And Config Values

If you inherited from [IgorModuleBase](Modules/Core/Core/Editor/IgorModuleBase.cs), you have several helper functions available to you to access and get the user's input for parameters and config values.

##### Getting User Input

You request the values that the user wants to use for a given job in DrawJobInspectorAndGetEnabledParams().  All values are stored entirely in the form of parameters and config values so everything is managed by passing around the job's current parameters.  In DrawJobInspectorAndGetEnabledParams() it's the string CurrentParams passed in as a parameter and after you're done getting input you return the updated full list of parameters from the function.

For bool values, you use:

```
bool DrawBoolParam(ref string CurrentParams, string BoolLabel, string BoolParam);
```

You pass the CurrentParams value by reference so that it can be updated, specify the label you want to be displayed next to the checkbox, and the final parameter is the parameter's flag (so for --builtname="Unity", the last value would be "builtname").

- It is highly recommended to put your flag names in a static variable on the class that uses it so that you can reference it everywhere in that class, but also potentially use it in modules that depend on your module.

For string values you have a few options.  The most common use case is to allow a user to set the value as either a per-job flag or as a config value.  You can do this with one function call to:

```
void DrawStringConfigParam(ref string CurrentParams, string StringLabel, string StringOverrideAndConfigKey);
```

The first two values are the same as with the bool, but the last value defines what key should be used for both the per-job flag and for the config value.  This function manages all of the user interaction so you don't need to care whether the user has chosen to use a per-job value or a config value for this specific value.

##### Retrieving The Value

To retrieve these values when you are in ProcessArgs() or executing one of your job step functions, you just need to make a single function call.

For bool values, you use the static function:

```
IgorJobConfig.IsBoolParamSet(string BoolParam);
```

Which returns true if the flag was enabled.

For string values, you use:

```
string GetParamOrConfigString(string StringKey, string EmptyStringWarningMessage = "", string DefaultValue = "", bool bCheckForEmpty = true)
```

If the parameter should be non-empty, you can optionally provide an Empty String Warning Message which will log a warning if the value is empty.

#### Job Steps

Job steps perform the actual work of the automated task.  These are registered and prioritized by calling:

```
StepHandler.RegisterJobStep(StepID CurrentStep, IIgorModule Module, IgorCore.JobStepFunc StepFunction);
```

The StepID contains a name for display purposes as well as a priority.  The lower the priority number, the early that step will run in the job.

- It's recommended to create the StepID using a static value on the class that requires it so that it can be shared with other dependent modules (for example see the BuildStep StepID in the [Build Common Module](Modules/Build/Common/Editor/IgorBuildCommon.cs)).
- The Module is usually just the this keyword.
- The StepFunction is the function you want called to actually perform the work of the job step.
	- This function returns a bool value of true if the function is done or false if the function needs to wait an update loop to continue (for example if you need to load a specific scene and wait for it to load before continuing to modify the scene).

#### Logging

If you inherited from [IgorModuleBase](Modules/Core/Core/Editor/IgorModuleBase.cs), you have several helper functions available to you for logging.  Use these functions unless you have a really good reason not to so that all the modules follow a consistent logging system.  The logging functions are:

```
void Log(string Message);
void LogWarning(string Message);
void LogError(string Message);
void CriticalError(string Message);
```

These functions correspond to Unity's Editor log levels.  Depending on the modules you have enabled, the logging functionality can change, but the built in logger module will output your message with a general filterable prefix and the name of the module that's logging the message.

#### Asserts

Igor has some general assert functions that are integrated with the job system.  All of the asserts are static functions on IgorAssert:

```
bool EnsureTrue(IIgorModule Module, bool bTrue, string FailMessage);
bool AssertTrue(IIgorModule Module, bool bTrue, string FailMessage);
bool VerifyTrue(IIgorModule Module, bool bTrue, string FailMessage);
```

Each function is designed to be used inside a conditional by passing the check's value back as the return value, for example:

```
if(IgorAssert.EnsureTrue(this, File.Exists(ExampleFile), "The file doesn't exist!  Oh no!"))
{
	return true;
}
```

- EnsureTrue will always run the check and if it fails it will log, mark the job as failed, and attempt to trigger a debugger breakpoint.
- AssertTrue will always run the check and if it fails and we are running in DEBUG, it will log, mark the job as failed, and attempt to trigger a debugger breakpoint.
- VerifyTrue will always run the check and if it fails it will only log the message.

If you have more complex logic that you want to write outside of an assert you can also manually flag a build as failed by calling:

```
IgorAssert.JobFailed();
```

#### Build Products

One way for the Modules to communicate with each other is by depending on a common module that can stash information relevant to all of the modules.  An example can be found in the [Build Common Module](Modules/Build/Common/Editor/IgorBuildCommon.cs) with build products.

The idea with build products is to keep track of the most recent build product so that each module can pick up from where the last one left off.  Here's an example flow:

1. The [Desktop Builder class](Modules/Build/Desktop/Editor/IgorBuildDesktop.cs) executes its Build() function which calls:

	```
	IgorBuildCommon.SetNewBuildProducts(BuiltFiles);
	```

	To track the built desktop app's file (let's say the file is called "Unity.exe" for example).
2. The [Zip class](Modules/Package/Zip/Editor/IgorZip.cs) executes the CreateZip() function which checks:

	```
	List<string> BuiltProducts = IgorBuildCommon.GetBuildProducts();
	```

	To retrieve all the files that were produced by the previous step so that it can zip them up.

	- In this way the Zip class doesn't need to know anything about Desktop building or how many files the Desktop build creates, it just needs to request a list from the common dependency.

	It then eventually calls:

	```
	IgorBuildCommon.SetNewBuildProducts(NewProducts);
	```

	Again to set the newly created zip file as the latest build product.  Note that it doesn't keep the old files around, but that you could include the build products that you were provided at the start of your module's job step in your job step's new build products list.

#### Best Practices

- Keep all of your flag names, config names, and StepIDs in static variables on the class with the highest reasonable reason to have them so that they can be shared across as many modules as possible.
- Always use the [IgorModuleBase](Modules/Core/Core/Editor/IgorModuleBase.cs) logging functions so that the logs stay consistent.
- Use the asserts as often as possible so that it's obvious when something goes wrong and provide a good failure message...trust me, you'll be glad you did.

## Dev environment setup

Here are some recommendations for how to set up your development environment for working on new Modules:

1. Create a new Unity project to contain your Igor working copy (make this a different project then the project you want to integrate Igor into).
2. Clone the GitHub repo into the Assets/ folder of the project you created in step 1.
3. Open the working copy project in Unity and go to Assets -> Sync MonoDevelop Project (or Visual Studio Tools -> Generate Project Files if you are using Visual Studio).
	- This will give you a project to edit later on when you want to make changes or create a new module.
4. In your project you want to use Igor with, make sure you have a copy of the Updater loaded and run Check for Updates.
5. Once you have at least the Core.Core module, go to the Editor Preferences (On Mac: Unity -> Preferences  On Windows: Edit -> Preferences).
6. Click on the Igor tab and enable Always update and Local update.
7. In the Local update directory put in a relative path to your Igor folder in the project you created in step 1.
	- If your main project is at projects/MyCoolGame/Assets and your Igor working copy project from step 1 is at projects/IgorGitHub/Assets/Igor/ then your relative path would be:
		../IgorGitHub/Assets/Igor/
8. Now whenever you tell Igor to check for updates, it will check this folder instead of the remote GitHub repo.
	- Currently it will still pull any files that have an explicit remote directory from the remote host.
9. Whenever you want to make changes, edit the files in your working copy, test them in your project (or projects) by checking for updates in your main project, and finally submit any changes to your working copy to GitHub.

This setup has a few big advantages:

1. You can test your changes across multiple projects locally and make sure it works for multiple different projects before submitting it to GitHub.
2. You don't have to keep incrementing version numbers or enable Always update and continually re-download files from GitHub.
3. The GitHub versioning doesn't interfere (or need to be configured to work with) the versioning system you are using for your projects.

## Local modules

Another useful feature is the ability to create custom modules that are only kept locally in your project.  You might have a custom build step that is unique to your project's build system and it doesn't make sense to submit it to the shared GitHub repo.  The section below describes making a new module in detail and outlines what you need to do to make your module local only.

## Making new modules

To create a module, I highly suggest you look through some of the other modules first to understand generally how they are structured and make sure to read all of this doc.  The general steps to creating a new module are:

1. Duplicate an existing module and place it under the appropriate folder structure (for Build.iOS, place the files under Modules/Build/iOS).
	- If you are using the recommended development environment setup, you put the files and folders in the working copy folder for a shared module or your primary project for a local module.
2. In the XML file, make sure the module name, files, and dependencies match what you need for your module and make sure that you reset your version number to 1.
3. Include at least one source file that derives from [IIgorModule](Modules/Core/Core/Editor/IIgorModule.cs).
4. Duplicate a module Readme.md file like the [Core Readme](Modules/Core/Core/Readme.md) and fill in the appropriate information for your module.
5. Add your module to the appropriate module list XML file.
	1. If you are creating a shared module to submit to GitHub, add your module to [Assets/Igor/IgorModuleList.xml](IgorModuleList.xml).  If you are using the recommended development environment setup, you want to add your module to the working copy's IgorModuleList.
	2. If you are creating a local module for your project only, add your module to Assets/Igor/IgorLocalModuleList.xml in your primary project.
		- If there isn't an IgorLocalModuleList.xml file, copy the [Assets/Igor/IgorModuleList.xml](IgorModuleList.xml) file and make sure the list only contains your new module.
		- The Local Modules List only tells Igor that the module should be included in the configuration window, so anything listed in that list will NOT update regardless of the type of update (local or remote) or if you have always update enabled.  The module is completely local to your project.
6. If you are creating a shared module and you are using the recommended development environment setup, you should edit your module in the working copy project and check for updates in the primary project for testing.
7. When your module is functional, submit your new module and the updated [IgorModuleList.xml](IgorModuleList.xml) to GitHub.
